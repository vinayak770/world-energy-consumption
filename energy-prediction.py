# -*- coding: utf-8 -*-
"""climate_app5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e4h7aBAa45_fdQTXATa3sOHuHsnSuGi9
"""

# World Energy Consumption ML Project - Fixed Version
# A simplified ML pipeline with Streamlit deployment

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import streamlit as st
import joblib
import os

# ----- 1: DATA LOADING AND EXPLORATION -----

def load_data():
    # Load the dataset (selecting a subset of columns for simplicity)
    df = pd.read_csv('world_energy_consumption.csv')

    # Select relevant columns for a simpler model
    selected_columns = [
        'country', 'year', 'population', 'gdp',
        'primary_energy_consumption', 'coal_consumption',
        'oil_consumption', 'gas_consumption'
    ]

    # Use only columns that exist in the dataset
    available_columns = [col for col in selected_columns if col in df.columns]
    df = df[available_columns]

    # Drop rows with missing values for simplicity
    df = df.dropna()

    # Filter for recent years (e.g., 2000 onwards) to make dataset smaller
    if 'year' in df.columns:
        df = df[df['year'] >= 2000]

    return df

# ----- 2: DATA PREPROCESSING -----

def preprocess_data(df):
    # For this simple model, we'll predict primary_energy_consumption based on other factors

    # Drop countries with too few data points
    country_counts = df['country'].value_counts()
    valid_countries = country_counts[country_counts >= 10].index
    df = df[df['country'].isin(valid_countries)]

    # Create a copy to avoid modifying the original dataframe
    df_processed = df.copy()

    # We'll focus on numeric columns and use country as a feature
    # One-hot encode the country (limit to top countries for simplicity)
    top_countries = df['country'].value_counts().nlargest(20).index
    df_processed = df_processed[df_processed['country'].isin(top_countries)]

    # Store the column order before one-hot encoding
    base_columns = [col for col in df_processed.columns if col != 'country']

    # One-hot encode the countries
    df_processed = pd.get_dummies(df_processed, columns=['country'], drop_first=False)

    # Save the column names to ensure consistency during prediction
    column_names = df_processed.columns.tolist()
    joblib.dump(column_names, 'column_names.pkl')

    # Save top countries for reference
    joblib.dump(top_countries.tolist(), 'top_countries.pkl')

    # Define features and target
    X = df_processed.drop(['primary_energy_consumption'], axis=1)
    y = df_processed['primary_energy_consumption']

    # Split the data
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    return X_train, X_test, y_train, y_test, top_countries, base_columns

# ----- 3: MODEL BUILDING -----

def build_model(X_train, X_test, y_train, y_test):
    # Create a pipeline with scaling and Linear Regression
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_test_scaled = scaler.transform(X_test)

    # Train a simple linear regression model
    model = LinearRegression()
    model.fit(X_train_scaled, y_train)

    # Make predictions
    y_pred = model.predict(X_test_scaled)

    # Evaluate the model
    mse = mean_squared_error(y_test, y_pred)
    rmse = np.sqrt(mse)
    r2 = r2_score(y_test, y_pred)

    print(f"Model Performance:")
    print(f"Root Mean Squared Error: {rmse:.2f}")
    print(f"R² Score: {r2:.2f}")

    # Save the scaler, model, and evaluation metrics
    joblib.dump(scaler, 'energy_scaler.pkl')
    joblib.dump(model, 'energy_model.pkl')
    joblib.dump({'rmse': rmse, 'r2': r2}, 'model_metrics.pkl')

    return model, scaler, rmse, r2

# ----- 4: STREAMLIT APP -----

def run_streamlit_app():
    st.title("World Energy Consumption Predictor")
    st.write("""
    ### Predict a country's energy consumption based on population, GDP, and fuel usage
    This simple model demonstrates how various factors relate to overall energy consumption.
    """)

    # Check if model files exist
    if not (os.path.exists('energy_model.pkl') and
            os.path.exists('energy_scaler.pkl') and
            os.path.exists('column_names.pkl') and
            os.path.exists('top_countries.pkl') and
            os.path.exists('model_metrics.pkl')):
        st.error("Please run the training process first (select 'Train Model' in the sidebar)")
        return

    # Load the required files
    df = load_data()
    model = joblib.load('energy_model.pkl')
    scaler = joblib.load('energy_scaler.pkl')
    column_names = joblib.load('column_names.pkl')
    top_countries = joblib.load('top_countries.pkl')
    metrics = joblib.load('model_metrics.pkl')
    rmse = metrics['rmse']
    r2 = metrics['r2']

    # Create input form
    st.sidebar.header("Input Parameters")

    # Country selection (offer all countries present in the dataset)
    all_countries = df['country'].unique()
    selected_country = st.sidebar.selectbox("Select Country", all_countries)

    # Year selection (use a reasonable range)
    year = st.sidebar.slider("Year", 2000, 2022, 2020)

    # Get population range for the selected country
    country_data = df[df['country'] == selected_country]

    # Population (use min/max from the country's data or reasonable defaults)
    pop_min = float(country_data['population'].min()) if not country_data.empty else 1000000
    pop_max = float(country_data['population'].max()) if not country_data.empty else 1500000000
    pop_default = float(country_data['population'].median()) if not country_data.empty else (pop_min + pop_max) / 2

    population = st.sidebar.slider(
        "Population",
        min_value=pop_min,
        max_value=pop_max,
        value=pop_default
    )

    # GDP (use min/max from the country's data or reasonable defaults)
    gdp_min = float(country_data['gdp'].min()) if not country_data.empty and 'gdp' in country_data.columns else 1e9
    gdp_max = float(country_data['gdp'].max()) if not country_data.empty and 'gdp' in country_data.columns else 2e13
    gdp_default = float(country_data['gdp'].median()) if not country_data.empty and 'gdp' in country_data.columns else (gdp_min + gdp_max) / 2

    gdp = st.sidebar.slider(
        "GDP (USD)",
        min_value=gdp_min,
        max_value=gdp_max,
        value=gdp_default,
        format="%e"
    )

    # Energy consumption inputs for coal, oil, and gas
    st.sidebar.subheader("Energy Source Consumption")

    # Coal consumption
    coal_min = float(country_data['coal_consumption'].min()) if not country_data.empty and 'coal_consumption' in country_data.columns else 0
    coal_max = float(country_data['coal_consumption'].max()) if not country_data.empty and 'coal_consumption' in country_data.columns else 100
    coal_default = float(country_data['coal_consumption'].median()) if not country_data.empty and 'coal_consumption' in country_data.columns else (coal_min + coal_max) / 2

    coal = st.sidebar.slider(
        "Coal Consumption (TWh)",
        min_value=coal_min,
        max_value=coal_max,
        value=coal_default
    )

    # Oil consumption
    oil_min = float(country_data['oil_consumption'].min()) if not country_data.empty and 'oil_consumption' in country_data.columns else 0
    oil_max = float(country_data['oil_consumption'].max()) if not country_data.empty and 'oil_consumption' in country_data.columns else 100
    oil_default = float(country_data['oil_consumption'].median()) if not country_data.empty and 'oil_consumption' in country_data.columns else (oil_min + oil_max) / 2

    oil = st.sidebar.slider(
        "Oil Consumption (TWh)",
        min_value=oil_min,
        max_value=oil_max,
        value=oil_default
    )

    # Gas consumption
    gas_min = float(country_data['gas_consumption'].min()) if not country_data.empty and 'gas_consumption' in country_data.columns else 0
    gas_max = float(country_data['gas_consumption'].max()) if not country_data.empty and 'gas_consumption' in country_data.columns else 100
    gas_default = float(country_data['gas_consumption'].median()) if not country_data.empty and 'gas_consumption' in country_data.columns else (gas_min + gas_max) / 2

    gas = st.sidebar.slider(
        "Gas Consumption (TWh)",
        min_value=gas_min,
        max_value=gas_max,
        value=gas_default
    )

    # Create a button to trigger prediction
    if st.sidebar.button("Predict Energy Consumption"):
        # Create a DataFrame with the same columns as the training data
        # Start with basic numeric features
        input_data = {
            'year': year,
            'population': population,
            'gdp': gdp,
            'coal_consumption': coal,
            'oil_consumption': oil,
            'gas_consumption': gas
        }

        # Initialize a DataFrame with all zero columns from the training data
        input_df = pd.DataFrame(columns=column_names)
        input_df = pd.concat([input_df, pd.DataFrame([{}])], ignore_index=True)
        input_df = input_df.fillna(0)

        # Fill in the basic features
        for key, value in input_data.items():
            if key in input_df.columns:
                input_df.at[0, key] = value

        # Set the selected country to 1
        country_col = f'country_{selected_country}'
        if country_col in input_df.columns:
            input_df.at[0, country_col] = 1

        # Make sure we have exactly the columns that were used in training
        missing_cols = set(column_names) - set(input_df.columns)
        for col in missing_cols:
            input_df[col] = 0

        # Ensure columns are in the same order as during training
        input_df = input_df[column_names]

        # Remove the target column if it's in the input data
        if 'primary_energy_consumption' in input_df.columns:
            input_df = input_df.drop(['primary_energy_consumption'], axis=1)

        # Scale the input data
        try:
            input_scaled = scaler.transform(input_df)

            # Make prediction
            prediction = model.predict(input_scaled)[0]

            # Display the prediction
            st.subheader("Prediction Result")
            st.write(f"Predicted Primary Energy Consumption: {prediction:.2f} TWh")

            # Create a pie chart showing the contribution of different energy sources
            st.subheader("Energy Source Distribution")

            labels = ['Coal', 'Oil', 'Gas']
            sizes = [coal, oil, gas]
            total = sum(sizes)

            if total > 0:
                # Create pie chart
                fig, ax = plt.subplots()
                ax.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)
                ax.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle
                st.pyplot(fig)

                # Compare prediction with sum of sources
                st.write(f"Sum of entered energy sources: {total:.2f} TWh")
                st.write(f"Difference from prediction: {prediction - total:.2f} TWh")

                if prediction > total:
                    st.write("This suggests other energy sources (like renewables, nuclear) contribute to the total.")
                else:
                    st.write("Note: The model's prediction may differ from the sum due to other factors like GDP and population influence.")

                # Display model accuracy
                st.subheader("Model Accuracy")
                st.write(f"Model R² Score: {r2:.4f}")
                st.write(f"Root Mean Squared Error: {rmse:.2f} TWh")

        except Exception as e:
            st.error(f"Error during prediction: {str(e)}")
            st.write("Please try retraining the model and ensure all input features match the training data.")

# ----- 5: MAIN EXECUTION FUNCTION -----

def main():
    st.sidebar.title("Energy Consumption ML Project")
    app_mode = st.sidebar.selectbox("Choose Mode", ["Train Model", "Make Predictions"])

    if app_mode == "Train Model":
        st.title("Train Model on World Energy Consumption Data")

        if st.button("Load Data and Train Model"):
            st.write("Loading data...")
            df = load_data()
            st.write(f"Loaded dataset with {df.shape[0]} rows and {df.shape[1]} columns")
            st.write("Sample of the data:")
            st.dataframe(df.head())

            st.write("Preprocessing data...")
            X_train, X_test, y_train, y_test, top_countries, base_columns = preprocess_data(df)
            st.write(f"Training with data from these countries: {', '.join(top_countries)}")

            st.write("Building and evaluating model...")
            model, scaler, rmse, r2 = build_model(X_train, X_test, y_train, y_test)

            st.success(f"Model trained successfully with R² Score: {r2:.4f}")
            st.info(f"Root Mean Squared Error: {rmse:.2f}")

            # Show feature importance (coefficients for linear regression)
            # Get non-country features and country features separately
            non_country_features = [col for col in X_train.columns if not col.startswith('country_')]
            country_features = [col for col in X_train.columns if col.startswith('country_')]

            coefficients = pd.DataFrame({
                'Feature': X_train.columns,
                'Coefficient': model.coef_
            }).sort_values('Coefficient', ascending=False)

            st.subheader("Feature Importance")
            st.dataframe(coefficients)

            # Create a bar chart of the top coefficients
            fig, ax = plt.subplots(figsize=(10, 6))
            top_features = coefficients.head(10)
            sns.barplot(x='Coefficient', y='Feature', data=top_features, ax=ax)
            ax.set_title('Top 10 Features by Importance')
            st.pyplot(fig)

            st.success("Model and scaler saved. You can now switch to 'Make Predictions' mode.")

    else:
        run_streamlit_app()

if __name__ == "__main__":
    main()

